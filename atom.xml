<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CTF reverse</title>
  
  <subtitle>llx-moon&#39;blogs</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-06T11:08:19.994Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>llx-moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QWB-re2</title>
    <link href="http://yoursite.com/2020/09/06/QWB-re2/"/>
    <id>http://yoursite.com/2020/09/06/QWB-re2/</id>
    <published>2020-09-06T11:08:19.000Z</published>
    <updated>2020-09-06T11:08:19.994Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QWB-re1</title>
    <link href="http://yoursite.com/2020/09/06/QWB-re1/"/>
    <id>http://yoursite.com/2020/09/06/QWB-re1/</id>
    <published>2020-09-06T11:06:04.060Z</published>
    <updated>2020-08-31T14:12:32.727Z</updated>
    
    <content type="html"><![CDATA[<p>首先恭喜BOI晋级强网杯决赛，多谢队伍里的大佬们在百忙之中抽出时间来打比赛，带小弟能够去线下见见世面。此次强网杯比赛逆向方向感觉题目难度分配的还是比较均匀的，强网先锋里的题目可以先找找自信，后面在逆向方向陆续出的题目也是由易到难不至于打的自闭。后面陆续会针对强网杯的每道题目做出详细分析，此篇先分析xx_warmup_obf。</p><p>动态调试该题可以看到会不断的出现int 3指令，推测应该里面应该加入反调试技术。</p><p><img src="/2020/09/06/QWB-re1/image-20200831201619445.png" alt="image-20200831201619445"></p><p>继续跟下去发现就是一个死循环，eax不论怎样都不会等于0x24c1d7a3，因此调试的话是肯定执行不到输入判断处。大致看了下程序在init_array存在一个sub_400B4C信号量处理函数</p><p><img src="/2020/09/06/QWB-re1/image-20200831204311020.png" alt="image-20200831204311020"></p><p>里面存在大量的赋值语句，估计该程序的反调试技术由于int 3指令执行导致不能触发信号量处理，解决的方法就是在判断语句处set寄存器的值为判断值就行（虽然很麻烦），根据信号量处理赋值语句的数量估计要改很多处判断，小编采取的是attach的方式改了不到5处判断就顺利进入到输入验证语句处。</p><p><img src="/2020/09/06/QWB-re1/image-20200831205307126.png" alt="image-20200831205307126"></p><p>首先会验证你的输入长度是否为0x1C，然后就是解28组方程，方程的变量数目依次增加，但每组方程只会解出一个变量，我在做这个题目时也想过去花指令直接f5然后z3解，但后来发现不现实，花指令完全没规律而且量多，最后小编是一步一步手扣下来，扣了几个小时才扣完。但后来想了想其实可以采取爆破的方式一次爆四个变量，且不需要把28个方程全部扣下来。但这也是个蠢办法。赛后看了大佬的wp其实可以用angr指定路径分析。你的输入都放置在rax指向的内存空间处，所以可以对rax设置一个内存地址，利用claripy对该地址初始化向量。这里稍微修改了下大佬的exp，并做了些注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line">p=angr.Project(<span class="string">&#x27;./xx_warmup_obf&#x27;</span>,auto_load_libs=<span class="literal">False</span>)</span><br><span class="line">state=p.factory.blank_state(addr=<span class="number">0x402d10</span>)<span class="comment">#指定入口</span></span><br><span class="line">tmp_addr=<span class="number">0x20000</span><span class="comment">#模拟一个内存地址用于存放输入</span></span><br><span class="line">ans=claripy.BVS(<span class="string">&#x27;ans&#x27;</span>,<span class="number">8</span>*<span class="number">28</span>)</span><br><span class="line">state.memory.store(tmp_addr,ans)<span class="comment">#往地址空间部署符号大小为8位长度为28的符号变量</span></span><br><span class="line">state.regs.rax=<span class="number">0x20000</span><span class="comment">#设置rax指向地址0x20000</span></span><br><span class="line">sm=p.factory.simgr(state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> byt <span class="keyword">in</span> ans.chop(<span class="number">8</span>):<span class="comment">#把整个数据分割每８位为一组，并对每个数据大小作出限制</span></span><br><span class="line">    state.add_constraints(state.solver.And(byt&gt;=ord(<span class="string">&#x27; &#x27;</span>),byt&lt;=ord(<span class="string">&#x27;~&#x27;</span>)))</span><br><span class="line">find=[<span class="number">0x408470</span>]<span class="comment">#最后一个方程的判断跳转地址</span></span><br><span class="line">avoid=[<span class="number">0x402d2f</span>,<span class="number">0x402f96</span>,<span class="number">0x4032c5</span>,<span class="number">0x4034b6</span>,<span class="number">0x4035cf</span>,<span class="number">0x403728</span>,<span class="number">0x4039d4</span>,<span class="number">0x403b27</span>,<span class="number">0x403cb9</span>,<span class="number">0x403e34</span>,<span class="number">0x40418f</span>,<span class="number">0x40459c</span>,<span class="number">0x4048fe</span>,<span class="number">0x404c6d</span>,<span class="number">0x405051</span>,<span class="number">0x405286</span>,<span class="number">0x405594</span>,<span class="number">0x4057ef</span>,<span class="number">0x405b96</span>,<span class="number">0x406057</span>,<span class="number">0x406537</span>,<span class="number">0x406931</span>,<span class="number">0x406da9</span>,<span class="number">0x407069</span>,<span class="number">0x407606</span>,<span class="number">0x40790b</span>,<span class="number">0x407d8f</span>,<span class="number">0x4081b4</span>]<span class="comment">#方程最后判断语句的下一个语句的地址</span></span><br><span class="line"><span class="keyword">print</span> (len(avoid))</span><br><span class="line"></span><br><span class="line">sm.explore(find=find,avoid=avoid)</span><br><span class="line"><span class="keyword">if</span> sm.found:</span><br><span class="line">    solution_state=sm.found[<span class="number">0</span>]</span><br><span class="line">    solution=solution_state.se.eval(ans,cast_to=bytes)</span><br><span class="line">    <span class="keyword">print</span> (solution)</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="/2020/09/06/QWB-re1/image-20200831214958257.png" alt="image-20200831214958257"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先恭喜BOI晋级强网杯决赛，多谢队伍里的大佬们在百忙之中抽出时间来打比赛，带小弟能够去线下见见世面。此次强网杯比赛逆向方向感觉题目难度分配的还是比较均匀的，强网先锋里的题目可以先找找自信，后面在逆向方向陆续出的题目也是由易到难不至于打的自闭。后面陆续会针对强网杯的每道题目</summary>
      
    
    
    
    <category term="linux-reverse" scheme="http://yoursite.com/categories/linux-reverse/"/>
    
    
    <category term="anti-debug" scheme="http://yoursite.com/tags/anti-debug/"/>
    
    <category term="angr" scheme="http://yoursite.com/tags/angr/"/>
    
  </entry>
  
  <entry>
    <title>深度fuzz:afl-fuzz+cov</title>
    <link href="http://yoursite.com/2020/08/17/afl-fuzz-cov/"/>
    <id>http://yoursite.com/2020/08/17/afl-fuzz-cov/</id>
    <published>2020-08-17T00:30:47.674Z</published>
    <updated>2020-08-17T12:05:27.891Z</updated>
    
    <content type="html"><![CDATA[<p>上周临时接了老师的安排要对libjpeg-turbo这个软件进行深度fuzz，相比于常规的fuzz（丢入种子，就在那等crash），还要求对fuzz过程中对代码覆盖率尽可能的高，以提升爆出crash的可能性。这就需要将afl-fuzz与代码覆盖率工具afl-cov结合使用起来，通过对fuzz过程未能执行的代码进行分析，对于限制种子通行一些无关的判断（如种子格式，大小等）通过修改源码的方式直接跳过。一下就以libjpeg软件为例，中间也会穿插下编译方面的小知识做下深度fuzz的过程解读。</p><p>libjpeg-turbo是一个图像处理软件，里面有很多的库是被一些著名大型软件调用的如google浏览器，火狐浏览器等，因此如果能爆出它动态链接库的洞em……（我也只是想想）。</p><p>先从编译开始说起吧，一般利用afl-fuzz首先都必须拿到目标源码利用afl专门的编译器afl-gcc，afl-g++进行编译，而一般在Linux里工程工程类源码都自带configure或CMakeLists.txt批处理编译文件，但一般这些文件的都指定编译器为gcc，g++，就需要对环境变量进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CC&#x3D;afl-gcc；export CXX&#x3D;afl-g++</span><br></pre></td></tr></table></figure><p>然后./configure文件或者执行cmake命令就可以产生makefile了。</p><p>afl-cov是一个方便观察fuzz过程中执行过的C语句的一款插件，使用的话<a href="https://github.com/mrash/afl-cov">https://github.com/mrash/afl-cov</a> 上有，和样例不同的是，目标如果是工程类文件需要在执行cmake时加上-DCMAKE_C_FLAGS=”-fprofile-arcs -ftest-coverage”，configure文件则需加上CFLAGS=”fprofile-arcs -ftest-coverage”，注意这个编译用的是gcc编译器，启动afl-cov的话里面它的–coverage-cmd的内容还需要根据你的种子输入方式来设置，如果是命令行输入则需要加上cat AFL_FILE|”目标文件执行命令”，如果是文件输入则不需要加上，这里小编在命令执行的过程中也出现了些问题lcov: ERROR: no valid records found in tracefile，后面查找了相关资料发现是因为gcc版本的问题，当小编用gcc&lt;8的版本就能执行成功了。</p><p>后续的话，就可以路径分析了。</p><p><img src="/2020/08/17/afl-fuzz-cov/1597665140917.png" alt="1597665140917"></p><p><img src="/2020/08/17/afl-fuzz-cov/1597665214580.png" alt="1597665214580"></p><p>深度fuzz其实也需要对源码的修改，但这种修改只能基于对一些因为种子的内容导致一些文件检测，校验判断不能通过导致不能深度执行，但不能修改其和内存有关的语句。如果能产生crash，可以反过来修改文件内容从过通过这些判断，可以真正产生crash，后续小编也会尝试这种操作，看能否提高crash的触发概率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上周临时接了老师的安排要对libjpeg-turbo这个软件进行深度fuzz，相比于常规的fuzz（丢入种子，就在那等crash），还要求对fuzz过程中对代码覆盖率尽可能的高，以提升爆出crash的可能性。这就需要将afl-fuzz与代码覆盖率工具afl-cov结合使用起</summary>
      
    
    
    
    
    <category term="afl-fuzz，afl-cov，cmake" scheme="http://yoursite.com/tags/afl-fuzz%EF%BC%8Cafl-cov%EF%BC%8Ccmake/"/>
    
  </entry>
  
  <entry>
    <title>WMCTF:welcome-to-ctf</title>
    <link href="http://yoursite.com/2020/08/15/welcome-to-ctf/"/>
    <id>http://yoursite.com/2020/08/15/welcome-to-ctf/</id>
    <published>2020-08-15T09:03:25.807Z</published>
    <updated>2020-08-15T13:08:18.963Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>这道题先不说算法，技术层面上就很有意思，反调试函数，硬件断点设置，以及VEH,UEF设置和注册都是借助GetProcAddress函数完成的，导致从import表无法查找到相关函数信息，有关VEH和UEF的相关知识可以看下大佬的这篇文章<a href="https://bbs.pediy.com/thread-226235.htm%E3%80%82">https://bbs.pediy.com/thread-226235.htm。</a></p><p>程序的反调试函数是NTInformationProcess，如果装了sharpOD后可以不用对其进行patch，可以直接到main函数，但main函数其实是一个假的验证函数，就是一个base64解密，但如何进入到正确的验证流程，还是得分析VEH和UEF在程序中的应用。先是对GetProcAddress函数下断。</p><p><img src="/2020/08/15/welcome-to-ctf/1.PNG" alt="1"></p><p>这个RtlAddVectoredExceptionHandler函数其实就是添加VEH异常处理函数</p><p><img src="/2020/08/15/welcome-to-ctf/1597483055033.png" alt="1597483055033"></p><p>这个SetUnhandledExceptionFilter是异常捕获主要用于对反调试检测触发，导致程序崩溃</p><p><img src="/2020/08/15/welcome-to-ctf/1597483731423.png" alt="1597483731423"></p><p><img src="/2020/08/15/welcome-to-ctf/1597483759671.png" alt="1597483759671"></p><p>这个getthreadcontext和setthreadcontext函数是配套使用的主要和硬件断点设置有关，在官方wp中也说了程序设置了4个硬件断点，刚好这一对函数也调用了四次。具体的硬件断点查看主要0x40121c处，这个可以从对SetUnhandledExceptionFilter的调用中得到信息。这个反调试函数也是真的隐藏的够深，真的感觉出题人用尽心思。</p><p><img src="/2020/08/15/welcome-to-ctf/1597484393338.png" alt="1597484393338"></p><p><img src="/2020/08/15/welcome-to-ctf/1597484117807.png" alt="1597484117807"></p><p><img src="/2020/08/15/welcome-to-ctf/1597492796065.png" alt="1597492796065"></p><p>可以看到里面正好有四个if语句刚好是四个硬件断点处分别对四个硬件断点做了VEH注册，当程序执行到硬件断点处会触发异常处理函数。对if处下断。</p><p><img src="/2020/08/15/welcome-to-ctf/1597493597566.png" alt="1597493597566"></p><p>可以看到0x4027C8是main函数中那个假的验证函数，当判断通过后修改了eip为0x402883，因此在0x402883才是真正的验证函数：</p><p><img src="/2020/08/15/welcome-to-ctf/1597494257162.png" alt="1597494257162"></p><p>整个一套流程就是魔改base64.decode()-&gt;RSA-768-&gt;x^3+z^3+80435758145817515^3=42。但是0x402316里面的表还不是真正魔改后的表。在第VEH注册函数中第三个判断又会对表进行修改，我是是真的吐了。后续调试的话就不能对main函数下断点了，因为有sharpOD的存在导致异常处理不能在调试过程中执行，只能对正确的判断函数下断。RSA-768的特征是从内存中看到它的n值判断来的，上网查它的p和q都有，三元三次方程则是根据看到了80435758145817515推测出来，但具体判断等于42在哪还是希望哪位师傅看到了能够指点一下。最后就是解密脚本了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line">stable=<span class="string">&quot;FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 09 FF FF FF 36 3F 08 2E 0C 04 1B 0A 00 27 2F FF FF FF FF FF FF FF 1D 35 29 0B 11 3B 05 31 15 07 10 23 28 02 26 18 37 1E 3C 1A 32 22 06 1F 2D 34 FF FF FF FF FF FF 19 17 30 3A 13 2C 0F 3E 33 38 0D 1C 01 12 14 16 3D 0E 20 2B 39 25 03 2A 21 24 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF&quot;</span></span><br><span class="line">stable=stable.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">b64stable=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(stable),<span class="number">3</span>):</span><br><span class="line">    tmp=<span class="string">&quot;&quot;</span></span><br><span class="line">    tmp+=stable[i]</span><br><span class="line">    tmp+=stable[i+<span class="number">1</span>]</span><br><span class="line">    b64stable.append(int(tmp,<span class="number">16</span>))</span><br><span class="line">    <span class="comment">#print tmp</span></span><br><span class="line">table=[<span class="string">&#x27;&#x27;</span>]*<span class="number">64</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b64stable)):</span><br><span class="line">    <span class="keyword">if</span> b64stable[i]!=<span class="number">255</span>:</span><br><span class="line">        table[b64stable[i]]=i</span><br><span class="line"><span class="comment">#print len(table)</span></span><br><span class="line">string1=<span class="string">&quot;&quot;</span>.join(map(chr,table))</span><br><span class="line"><span class="keyword">print</span> string1</span><br><span class="line">string2=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">n=<span class="number">1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413</span></span><br><span class="line">p = <span class="number">33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489</span></span><br><span class="line">q = <span class="number">36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917</span></span><br><span class="line">d=<span class="number">0x10001</span></span><br><span class="line">m=<span class="number">5803427745647280975433812866345295</span> </span><br><span class="line"><span class="comment">#x^3+y^3+z^3=42 z确定z=80435758145817515，此处的m为xy拼接后的值</span></span><br><span class="line">phiN = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) </span><br><span class="line">e = gmpy2.invert(d, phiN)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;e =&#x27;</span>, hex(e)</span><br><span class="line">enc = pow(m, e, n)</span><br><span class="line"><span class="keyword">print</span> enc</span><br><span class="line">b64 = hex(enc)[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> len(b64)</span><br><span class="line">tmp=<span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(b64),<span class="number">2</span>):</span><br><span class="line">    tmp+=chr(int(b64[i:i+<span class="number">2</span>],<span class="number">16</span>))</span><br><span class="line">flag = <span class="string">&#x27;WMCTF&#123;&#x27;</span> + tmp.encode(<span class="string">&quot;base64&quot;</span>).translate(string.maketrans(string2,string1)).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;&#125;&#x27;</span> </span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这道题先不说算法，技术层面上就很有意思，反调试函数，硬件断点设置，以及VEH,UEF设置和注册都是借助GetProcAddress函数完成的，导致从import表无法查找到相关函数信息，有关VEH和UEF的相关知识可以看下大佬的这篇文章&lt;</summary>
      
    
    
    
    <category term="windows-reverse" scheme="http://yoursite.com/categories/windows-reverse/"/>
    
    
    <category term="anti-debug" scheme="http://yoursite.com/tags/anti-debug/"/>
    
    <category term="UEF" scheme="http://yoursite.com/tags/UEF/"/>
    
    <category term="VEH" scheme="http://yoursite.com/tags/VEH/"/>
    
    <category term="RSA" scheme="http://yoursite.com/tags/RSA/"/>
    
    <category term="魔改base64" scheme="http://yoursite.com/tags/%E9%AD%94%E6%94%B9base64/"/>
    
  </entry>
  
</feed>
